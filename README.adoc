= OpenRewrite - demo
:toc:
:toc-placement:

This is a sample project to showcase some of the functionalities of https://https://docs.openrewrite.org/[OpenRewrite]

OpenRewrite allows us to do major refactorings on our source code using (prewritten) recipes.
It works by making changes to the https://docs.openrewrite.org/concepts-explanations/lossless-semantic-trees[Lossless Semantic Trees] representing our source code and printing the modifications back to the source code/diffs which we can then compare and commit if we deem them ok.

'''

== Use cases

* fixes: (log4shell, spring4shell, ...)
* migrations: (log4j => slf4j, java 8 => 11 => 17, JUnit 4 => 5, ...)
* code quality/refactoring: autoformatting, resolve issues by SAST tools, remove unused imports, apply a new convention using a recipe, ...
* utility: generate a CycloneDx bill of materials

== Setup

OpenRewrite can be run using the Maven/Gradle build plugin tools or directly from a java main method of a build tool plugin isn't possible (https://docs.openrewrite.org/running-recipes/running-rewrite-without-build-tool-plugins[see for reference])

Both for Maven and Gradle we can run the migrations either by modifying our build files, or by running a shell command or init script respectively.

=== Maven

If we add the plugin to our pom.xml file

[source]
----
<plugin>
  <groupId>org.openrewrite.maven</groupId>
  <artifactId>rewrite-maven-plugin</artifactId>
  <version>5.3.1</version>
</plugin>
----

=== Gradle

For Gradle we need to be certain that mavenCentral() is present in our repositories section, then we need to add the following to our build file:

[source]
----
plugins {
    id 'org.openrewrite.rewrite' version '6.1.16'
}

repositories {
  // needed to resolve recipe artifacts
  mavenCentral()
}

rewrite {
    // here we'll place the recipes we wish to use
}
----

After which we can try `./mvnw rewrite:discover` or `./gradlew rewriteDiscover` to discover which recipes we can run from OpenRewrite using this setup. (we can add other sources/write our own).

== Usage

=== Adding a recipe without configuration

Some OpenRewrite recipes require some configuration, but we'll start easy with a standard OpenRewrite which doesn't need any setup.

For example, if you have a project with a lot of unused imports you can use the `org.openrewrite.java.RemoveUnusedImports` recipe which is part of the core library.

==== Maven
a) run `mvn -U org.openrewrite.maven:rewrite-maven-plugin:run -Drewrite.activeRecipes=org.openrewrite.java.RemoveUnusedImports`

b) add `<recipe>org.openrewrite.java.RemoveUnusedImports</recipe>` to the `<activeRecipes>` in your pom file and perform `./mvnw rewrite:run`

==== Gradle

Add `activeRecipe("org.openrewrite.java.RemoveUnusedImports")` and perform `./gradlew rewriteRun`

If we were to run this one on the current project, and then execute a `git diff` we'd see:

[source]
----
diff --git a/src/main/java/dev/simonverhoeven/openrewritedemo/OpenrewritedemoApplication.java b/src/main/java/dev/simonverhoeven/openrewritedemo/OpenrewritedemoApplication.java
index d97b878..8e85aaf 100644
--- a/src/main/java/dev/simonverhoeven/openrewritedemo/OpenrewritedemoApplication.java
+++ b/src/main/java/dev/simonverhoeven/openrewritedemo/OpenrewritedemoApplication.java
@@ -3,8 +3,6 @@ package dev.simonverhoeven.openrewritedemo;
 import org.springframework.boot.SpringApplication;
 import org.springframework.boot.autoconfigure.SpringBootApplication;

-import java.math.BigDecimal;
-
 @SpringBootApplication
 public class OpenrewritedemoApplication {
----

=== Adding a recipe with a configuration

Some recipes require a configuration. Let's start with an easy one.
Say your organisation changes name, and suddenly you need to rewrite your package names.

For this, we can use the `org.openrewrite.java.ChangePackage` recipe.

To set it up we'll need to create a `rewrite.yml`  in which we'll define a recipe name, optionally a display name and the recipe list with the parameters.
In this case we'll be renaming `dev.simonverhoeven.openrewritedemo.oldorgname` to `dev.simonverhoeven.openrewritedemo.neworgname`

[source]
----
---
type: specs.openrewrite.org/v1beta/recipe
name: dev.simonverhoeven.sampleRecipe
displayName: A simple recipe
recipeList:
  - org.openrewrite.java.ChangePackage:
      oldPackageName: dev.simonverhoeven.openrewritedemo.oldorgname
      newPackageName: dev.simonverhoeven.openrewritedemo.neworgname
      recursive: null
----

Then we'll add `dev.simonverhoeven.sampleRecipe` to our active recipes.

When we then run the rewrite we'll see that our `oldorgname` has been renamed to `neworgname` and that the package statement in our `Sample` file has also been adapted.

=== Without build tool plugins

It is possible to use OpenRewrite without the build tool plugins, the hardest part is determining the applicable classpath for each set of files.
A brief overview on the approach is documented https://docs.openrewrite.org/running-recipes/running-rewrite-without-build-tool-plugins[here] on the OpenRewrite website.

== The real power

For now, we've used 2 quite basic recipes, which had relatively limited impact.
So let's try something a bit more impactful.

Say our company's finally ready to take the leap forwards to java 17 & spring boot 3.1. And we'd love to finally start using `spring-boot-starter-test`

Now we'd like to take the sensible approach and make certain that all our test run possible. Now here's where we stumble upon a small hiccup. For some reason our project's using JUnit 4, not 5 and Spring boot 2.2 the backward compatibility with spring JUnit 4 has been dropped.

Now we know that the upgrade to JUnit 5 entails a couple of steps for which there are recipes

* `@Ignore` => `@Disabled`: `org.openrewrite.java.testing.junit5.IgnoreToDisabled`
* `org.junit.Assert` => `org.junit.jupiter.api.Assertions`: `org.openrewrite.java.test.junit5.AssertToAssertions`
* `org.junit.Test` => `org.junit.jupiter.api.Test`: `org.openrewrite.java.test.junit5.UpdateTestAnnotation`
* @Junit 4's `@Rule ExpectedException => JUnit 5's `Assertions.assertThrows()`: `org.openrewrite.java.testing.junit5.ExpectedExceptionToAssertThrows`
* ...

And that's the premise behind OpenRewrite, large migrations in small steps.

One of the recipes we can use for this is https://docs.openrewrite.org/recipes/java/testing/junit5/junit4to5migration[org.openrewrite.java.testing.junit5.JUnit4to5Migration] for which we'll need a dependency on `org.openrewrite.recipe:rewrite-testing-frameworks:2.0.7`.

When we execute this recipe we'll get

[code]
----
[WARNING] Changes have been made to pom.xml by:
[WARNING]     org.openrewrite.java.testing.junit5.JUnit4to5Migration
[WARNING]         org.openrewrite.java.dependencies.RemoveDependency: {groupId=junit, artifactId=junit}
[WARNING]             org.openrewrite.maven.RemoveDependency: {groupId=junit, artifactId=junit}
[WARNING]         org.openrewrite.java.dependencies.AddDependency: {groupId=org.junit.jupiter, artifactId=junit-jupiter, version=5.x, onlyIfUsing=org.junit.jupiter.api.Test, acceptTransitive=true}
[WARNING]             org.openrewrite.maven.AddDependency: {groupId=org.junit.jupiter, artifactId=junit-jupiter, version=5.x, onlyIfUsing=org.junit.jupiter.api.Test, acceptTransitive=true}
[WARNING] Changes have been made to src\test\java\dev\simonverhoeven\openrewritedemo\JunitTest.java by:
[WARNING]     org.openrewrite.java.testing.junit5.JUnit4to5Migration
[WARNING]         org.openrewrite.java.testing.junit5.IgnoreToDisabled
[WARNING]             org.openrewrite.java.ChangeType: {oldFullyQualifiedTypeName=org.junit.Ignore, newFullyQualifiedTypeName=org.junit.jupiter.api.Disabled}
[WARNING]         org.openrewrite.java.testing.junit5.AssertToAssertions
[WARNING]         org.openrewrite.java.testing.junit5.CategoryToTag
[WARNING]         org.openrewrite.java.testing.junit5.TemporaryFolderToTempDir
[WARNING]         org.openrewrite.java.testing.junit5.UpdateBeforeAfterAnnotations
[WARNING]         org.openrewrite.java.testing.junit5.UpdateTestAnnotation
[WARNING]         org.openrewrite.java.testing.junit5.ExpectedExceptionToAssertThrows

----

If we then run a `git diff` to see the changes that were made we'll notice that our `pom.xml` has been upgraded, our imports are now from the `jupiter` hierarchy, `@Ignore` => `@Disabled`, `Assert.*` => `Assertions.*`, ...

*note:* there are multiple recipes that can be used from this. For example there's also `org.openrewrite.recipe:rewrite-spring:4.35.0` which is a superset of of the JUnit 4 to 5 & Mockito 1 to 3 recipes.

== How does it work?

OpenRewrite makes changes to the **L**osless **S**emantic **T**ree representation of your code using *visitors*.
*Visitors* are basically event handlers, which deal with *what* to do, and *when* to do it that get triggered as OpenRewrite goes through the LST translation of our codebase.
These *visitors* can in turn be gathered into *recipes*

== References
* https://docs.openrewrite.org/[OpenRewrite documentation]
* https://docs.openrewrite.org/authoring-recipes[Creating your own recipe]
* https://docs.openrewrite.org/recipes[OpenRewrite Recipe catalog]
* https://www.moderne.io/[Moderne] - platform to automate migrating, securing and maintaining source code. Uses OpenRewrite recipes, and offers certain extra features like data tables to view the changes that were made
* https://github.com/spring-projects-experimental/spring-boot-migrator[Spring boot migrator] - a CLI tool which offers recipes to migrate/upgrade an application to Spring boot and is compatible with & uses OpenRewrite

== Notes

If you have a multimodule maven project you might run into errors when using the maven plugin, a workaround & more information is documented https://docs.openrewrite.org/running-recipes/multi-module-maven[here].